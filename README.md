This repo contains a personal game project of mine that turned into research on in-memory database techniques for [Entity Component Systems (ECSs)](https://en.wikipedia.org/wiki/Entity_component_system). The interesting bits you'll find in this repo are:
* [An MB+ tree implementation.](Game/Database/MBPlusTree.h) This is a variant of B+ trees that always contains three levels and uses a sorted contiguous array at the root, which exploits the fact that the workload of a B+ tree closer to the root is read-heavy.
* [A columnar representation](Game/Database/Columnar.h) that provides nice syntax for manipulation of [database rows](Game/Database/Row.h) via C++ templates. [Boost MPL](https://github.com/boostorg/mpl) is used for template metaprogramming.
* A set of operations for building queries over MB+ tree indices (see the various files in [Game/Database](Game/Database)). For example, [MergeJoin.h](Game/Database/MergeJoin.h) provides a join for indices on the same key, while [FindJoin.h](Game/Database/FindJoin.h) works for any indices. The query operators are all implemented as C++ templates, which enables AoT code generation game simulations where all required queries are typically known ahead-of-time.
* [A work-stealing task system](Game/Concurrency) implemented on top of [User-Mode Scheduling](https://learn.microsoft.com/en-us/windows/win32/procthread/user-mode-scheduling). UMS threads strike a balance between system threads (each UMS thread has its own stack) and fibers (UMS threads are scheduled in user-mode). While this was a fun technology to learn about, UMS was already being deprecated when I built this and no longer exists in Windows 11, so this part is unlikely to be useful today.
* [A game loop implementation](Game/Core/GameLoop.cpp) that uses filtered moving averages to predict both simulation and rendering times, and uses those predictions to achieve smooth frame pacing.
